# PKU-PTA

## step 1: 调用图

这里为了方便，上下文敏感不考虑循环调用（例如递归）的情况，这样调用图实际上可以变成调用树。从 `main` 开始，对所有 `Invoke` 进行后序遍历，可以得到调用树上的一个拓扑排序。

数据结构上，用一个 `Map<JMethod, Integer>` 保存所有已找到的方法，然后用一个 `List<MethodThings>` 保存拓扑排序和后续会用到的信息。map 建立了方法到排序的映射。

## step 2: 方法摘要（Sumup）

## step 2.1: 控制流图（CFG）

此处，为了应对一些流敏感的情况（主要是包括了多次对同一个指针赋值造成的覆盖），我们对方法建立控制流图。此处我们只考虑简单的控制流，即不考虑 `invoke` 带来的控制流变化。

## step 2.2: 拷贝关系（Copy relationship）

对每个方法都确定出是否存在指针间拷贝关系：`{a = [b, ...]}`，即 `a` 可能被 `[b, ...]` 赋值。

原理上来说，在每个控制流的基本块中，考察本基本块的 GEN 和 KILL，然后在基本块之间求解。

实际上为了简化实现，各基本块通过一次对 ir 的遍历确定，而基本块间则通过一个简单的迭代方法计算。

## step 2.3: 方法摘要

在某方法算出拷贝关系后，我们对 EXIT 处的，关于入参（包括 `this`）的拷贝关系进行摘要。所有与入参有关的拷贝关系（入参在左侧）会形成摘要表。

当在 step 2.2 的基本块中遇到 `Invoke` 时，直接使用拷贝关系，而不触发递归调用。通过 step 1 的调用图，我们可以确保在无循环引用的情况下，所有方法此时都已经获得摘要了。

## step 3: 指针分析

在 step 1 顺便记录哪些方法有 `benchmark`，此时直接将该方法的拷贝关系找出，然后通过迭代计算即可求解。
